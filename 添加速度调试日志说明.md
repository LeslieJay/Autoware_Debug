# Planning 模块速度调试日志添加说明

## 📋 概述

本文档说明如何在 Autoware Planning 模块中添加 `longitudinal_velocity_mps` 相关的调试日志，以便跟踪速度计算和传递过程。

---

## 🎯 关键文件和位置

### 1. Behavior Path Planner (BPP) - 核心模块

#### 文件: `behavior_path_planner_node.cpp`
**功能**: BPP 主节点，输出最终路径

**关键位置**:
- 路径发布前
- 速度设置后

#### 文件: `goal_planner_module.cpp`
**功能**: 目标点规划，设置停车速度

**关键位置**:
- `decideVelocity()` - 决定速度的函数
- 路径生成后的速度设置

#### 文件: `static_obstacle_avoidance_module.cpp`
**功能**: 静态障碍物避让

**关键位置**:
- `insertAvoidanceVelocity()` - 插入避障速度
- 速度平滑处理

---

### 2. Behavior Velocity Planner - 场景速度规划

#### 文件: `traffic_light_module/src/scene.cpp`
**功能**: 红绿灯停止线速度控制

#### 文件: `crosswalk_module/src/scene_crosswalk.cpp`
**功能**: 人行横道速度控制

#### 文件: `intersection_module/src/scene_intersection_collision.cpp`
**功能**: 路口速度控制

---

### 3. Motion Velocity Planner - 运动速度规划

#### 文件: `obstacle_cruise_module/src/pid_based_planner.cpp`
**功能**: 基于 PID 的巡航速度规划

#### 文件: `obstacle_cruise_module/src/optimization_based_planner.cpp`
**功能**: 基于优化的速度规划

---

### 4. Obstacle Cruise Planner - 障碍物巡航

#### 文件: `autoware_obstacle_cruise_planner/src/node.cpp`
**功能**: 障碍物巡航主节点

#### 文件: `autoware_obstacle_cruise_planner/src/pid_based_planner.cpp`
**功能**: PID 巡航规划器

---

### 5. Path Smoother - 路径平滑

#### 文件: `autoware_path_smoother/src/elastic_band_smoother.cpp`
**功能**: 弹性带平滑器，会修改速度

---

## 🛠️ 添加日志的方法

### 方法1: 使用 RCLCPP_INFO_THROTTLE (推荐)

**优点**: 限制日志频率，避免刷屏

```cpp
// 每秒最多输出一次
RCLCPP_INFO_THROTTLE(
  get_logger(), 
  *get_clock(), 
  1000,  // 毫秒
  "[VEL_DEBUG] 模块名: 速度值 = %.2f m/s, 位置: 函数名/行号",
  velocity_value
);
```

### 方法2: 使用 RCLCPP_DEBUG

**优点**: 可通过日志级别控制开关

```cpp
RCLCPP_DEBUG(
  get_logger(),
  "[VEL_DEBUG] 详细信息: velocity = %.3f",
  velocity_value
);
```

### 方法3: 添加诊断信息

**优点**: 可通过 `/diagnostics` 话题实时查看

```cpp
diagnostic_msgs::msg::DiagnosticStatus status;
status.name = "velocity_debug";
status.level = diagnostic_msgs::msg::DiagnosticStatus::OK;
status.message = "Velocity: " + std::to_string(velocity);
```

---

## 📝 推荐的日志格式

### 统一格式
```
[VEL_DEBUG][模块名][阶段] 描述: 速度值, 附加信息
```

### 示例

```cpp
// BPP 输出
RCLCPP_INFO_THROTTLE(
  get_logger(), *get_clock(), 1000,
  "[VEL_DEBUG][BPP][OUTPUT] Final path velocity: %.2f m/s, points: %zu",
  output_path.points.front().point.longitudinal_velocity_mps,
  output_path.points.size()
);

// Goal Planner
RCLCPP_INFO(
  get_logger(),
  "[VEL_DEBUG][GoalPlanner][DECIDE] Current vel: %.2f, min vel: %.2f, decided vel: %.2f",
  current_vel,
  min_vel,
  decided_vel
);

// Avoidance
RCLCPP_INFO_THROTTLE(
  get_logger(), *get_clock(), 1000,
  "[VEL_DEBUG][Avoidance][INSERT] Original: %.2f -> Modified: %.2f at idx %zu",
  v_original,
  v_target,
  i
);
```

---

## 🔍 关键函数添加位置

### 1. BPP 主节点输出

**文件**: `behavior_path_planner_node.cpp`

**函数**: `run()` 或 `publishPath()`

**添加位置**: 发布路径前

```cpp
// 在发布前添加
if (!output.path.points.empty()) {
  RCLCPP_INFO_THROTTLE(
    get_logger(), *get_clock(), 1000,
    "[VEL_DEBUG][BPP][PUBLISH] Output path first point vel: %.3f m/s, last point vel: %.3f m/s",
    output.path.points.front().point.longitudinal_velocity_mps,
    output.path.points.back().point.longitudinal_velocity_mps
  );
}
```

---

### 2. Goal Planner 速度决策

**文件**: `goal_planner_module.cpp`

**函数**: `decideVelocity()`

```cpp
void GoalPlannerModule::decideVelocity(PullOverPath & pull_over_path)
{
  const double current_vel = planner_data_->self_odometry->twist.twist.linear.x;
  
  auto & first_path = pull_over_path.partial_paths().front();
  const auto vel = static_cast<float>(
    std::max(current_vel, parameters_.pull_over_minimum_velocity)
  );
  
  // 添加日志
  RCLCPP_INFO(
    get_logger(),
    "[VEL_DEBUG][GoalPlanner][DECIDE] current_vel=%.3f, min_vel=%.3f, decided_vel=%.3f",
    current_vel,
    parameters_.pull_over_minimum_velocity,
    vel
  );
  
  for (auto & p : first_path.points) {
    const auto old_vel = p.point.longitudinal_velocity_mps;
    p.point.longitudinal_velocity_mps = std::min(p.point.longitudinal_velocity_mps, vel);
    
    // 如果速度被修改，打印日志
    if (std::abs(old_vel - p.point.longitudinal_velocity_mps) > 0.01) {
      RCLCPP_DEBUG(
        get_logger(),
        "[VEL_DEBUG][GoalPlanner][MODIFY] Point velocity: %.3f -> %.3f",
        old_vel,
        p.point.longitudinal_velocity_mps
      );
    }
  }
}
```

---

### 3. 避障速度插入

**文件**: `static_obstacle_avoidance_module.cpp`

**函数**: `insertAvoidanceVelocity()`

```cpp
void StaticObstacleAvoidanceModule::insertAvoidanceVelocity(ShiftedPath & shifted_path) const
{
  // ... 现有代码 ...
  
  const auto [distance_to_accel_end_point, v_max] =
    helper_->getDistanceToAccelEndPoint(shifted_path.path);
    
  // 添加日志
  RCLCPP_INFO_THROTTLE(
    get_logger(), *get_clock(), 1000,
    "[VEL_DEBUG][Avoidance][INSERT] v_max=%.3f, distance_to_accel=%.3f",
    v_max,
    distance_to_accel_end_point
  );
  
  if (distance_to_accel_end_point < 1e-3) {
    RCLCPP_WARN_THROTTLE(
      get_logger(), *get_clock(), 2000,
      "[VEL_DEBUG][Avoidance][SKIP] Distance too small, skipping velocity insertion"
    );
    return;
  }
  
  // ... 在循环中 ...
  for (size_t i = start_idx; i < shifted_path.path.points.size(); ++i) {
    const double v_original = shifted_path.path.points.at(i).point.longitudinal_velocity_mps;
    const double v_target = std::max(getEgoSpeed(), std::sqrt(v_target_square));
    shifted_path.path.points.at(i).point.longitudinal_velocity_mps = std::min(v_original, v_target);
    
    // 每10个点打印一次
    if (i % 10 == 0) {
      RCLCPP_DEBUG(
        get_logger(),
        "[VEL_DEBUG][Avoidance][POINT_%zu] %.3f -> %.3f (ego_speed=%.3f)",
        i, v_original, shifted_path.path.points.at(i).point.longitudinal_velocity_mps, getEgoSpeed()
      );
    }
  }
}
```

---

### 4. Obstacle Cruise Planner

**文件**: `autoware_obstacle_cruise_planner/src/node.cpp`

**函数**: `onTrajectory()` 或速度计算函数

```cpp
// 在计算速度后添加
RCLCPP_INFO_THROTTLE(
  get_logger(), *get_clock(), 1000,
  "[VEL_DEBUG][ObstacleCruise][PLAN] Input vel: %.3f, Output vel: %.3f, obstacle dist: %.3f",
  input_trajectory.points.front().longitudinal_velocity_mps,
  output_trajectory.points.front().longitudinal_velocity_mps,
  obstacle_distance
);
```

---

### 5. Path Smoother

**文件**: `autoware_path_smoother/src/elastic_band_smoother.cpp`

```cpp
// 平滑前后对比
RCLCPP_INFO_THROTTLE(
  get_logger(), *get_clock(), 1000,
  "[VEL_DEBUG][PathSmoother][SMOOTH] Before: avg_vel=%.3f, After: avg_vel=%.3f",
  avg_vel_before,
  avg_vel_after
);
```

---

## 🚀 快速添加脚本

### 自动添加调试日志的辅助脚本

```bash
#!/bin/bash
# 文件名: add_velocity_debug_logs.sh

# 备份文件
backup_file() {
  if [ ! -f "$1.bak" ]; then
    cp "$1" "$1.bak"
    echo "已备份: $1 -> $1.bak"
  fi
}

# 在文件中查找并标记 longitudinal_velocity_mps 的位置
find_velocity_usage() {
  local file=$1
  echo "=== $file ==="
  grep -n "longitudinal_velocity_mps" "$file" | head -20
  echo ""
}

# 主目录
PLANNING_DIR="src/universe/autoware_universe/planning"

# 关键文件列表
KEY_FILES=(
  "$PLANNING_DIR/behavior_path_planner/autoware_behavior_path_planner/src/behavior_path_planner_node.cpp"
  "$PLANNING_DIR/behavior_path_planner/autoware_behavior_path_goal_planner_module/src/goal_planner_module.cpp"
  "$PLANNING_DIR/behavior_path_planner/autoware_behavior_path_static_obstacle_avoidance_module/src/scene.cpp"
  "$PLANNING_DIR/autoware_obstacle_cruise_planner/src/node.cpp"
  "$PLANNING_DIR/autoware_obstacle_cruise_planner/src/pid_based_planner/pid_based_planner.cpp"
)

echo "正在扫描关键文件中的速度使用情况..."
echo "================================================"
echo ""

for file in "${KEY_FILES[@]}"; do
  if [ -f "$file" ]; then
    find_velocity_usage "$file"
  else
    echo "文件不存在: $file"
  fi
done

echo "================================================"
echo "扫描完成！"
echo ""
echo "建议手动在以上位置添加调试日志"
echo "格式: RCLCPP_INFO_THROTTLE(get_logger(), *get_clock(), 1000, \"[VEL_DEBUG]...\")"
```

**使用方法**:
```bash
chmod +x add_velocity_debug_logs.sh
./add_velocity_debug_logs.sh > velocity_usage_report.txt
```

---

## 📊 日志分析工具

### 实时过滤速度日志

```bash
#!/bin/bash
# 文件名: monitor_velocity_logs.sh

echo "实时监控 Planning 模块速度日志..."
echo "按 Ctrl+C 退出"
echo "========================================"

# 方法1: 从 ROS 日志过滤
ros2 topic echo /rosout | grep --line-buffered "\[VEL_DEBUG\]"

# 方法2: 从系统日志过滤（如果使用文件日志）
# tail -f ~/.ros/log/latest/autoware-*.log | grep --line-buffered "\[VEL_DEBUG\]"
```

### 提取速度变化历史

```bash
#!/bin/bash
# 文件名: extract_velocity_history.sh

LOG_FILE="${1:-~/.ros/log/latest/*.log}"

echo "从日志中提取速度变化历史..."

grep "\[VEL_DEBUG\]" $LOG_FILE | \
  awk '{
    # 提取时间戳和速度值
    if (match($0, /vel[^0-9]*([0-9.]+)/, arr)) {
      print $1, $2, arr[1]
    }
  }' | \
  sort -k2 > velocity_history.txt

echo "已保存到 velocity_history.txt"
```

---

## 🎨 RViz 可视化配置

### 添加速度显示

1. 在 RViz 中添加 `Path` 或 `Trajectory` 显示
2. 启用速度颜色映射
3. 根据 `longitudinal_velocity_mps` 着色

**配置示例**:
```yaml
- Class: rviz_default_plugins/Path
  Name: BPP Output Path
  Topic: /planning/scenario_planning/lane_driving/behavior_planning/path
  Color Scheme: Color by velocity
  Min Velocity: 0.0
  Max Velocity: 2.0
```

---

## 🔧 编译和测试

### 修改后重新编译

```bash
# 仅编译 planning 相关包
colcon build --packages-select \
  autoware_behavior_path_planner \
  autoware_behavior_path_goal_planner_module \
  autoware_behavior_path_static_obstacle_avoidance_module \
  autoware_obstacle_cruise_planner \
  --cmake-args -DCMAKE_BUILD_TYPE=Debug

# 重新 source
source install/setup.bash
```

### 测试日志输出

```bash
# 启动 Autoware
ros2 launch autoware_launch e2e_simulator.launch.xml ...

# 在另一个终端监控日志
ros2 topic echo /rosout | grep "\[VEL_DEBUG\]"
```

### 调整日志级别

```bash
# 设置为 DEBUG 级别以查看所有日志
ros2 run rqt_logger_level rqt_logger_level

# 或命令行设置
ros2 service call /behavior_path_planner/set_log_level \
  rcl_interfaces/srv/SetLoggerLevel \
  "{logger_name: '', level: 10}"
```

---

## 📈 预期日志输出示例

```
[INFO] [1234567890.123] [behavior_path_planner]: [VEL_DEBUG][BPP][PUBLISH] Output path first point vel: 1.234 m/s, last point vel: 0.000 m/s

[INFO] [1234567890.456] [goal_planner]: [VEL_DEBUG][GoalPlanner][DECIDE] current_vel=1.200, min_vel=0.300, decided_vel=1.200

[INFO] [1234567890.789] [static_obstacle_avoidance]: [VEL_DEBUG][Avoidance][INSERT] v_max=1.500, distance_to_accel=10.500

[DEBUG] [1234567891.012] [static_obstacle_avoidance]: [VEL_DEBUG][Avoidance][POINT_0] 1.500 -> 1.234 (ego_speed=1.200)

[INFO] [1234567891.345] [obstacle_cruise_planner]: [VEL_DEBUG][ObstacleCruise][PLAN] Input vel: 1.234, Output vel: 0.800, obstacle dist: 5.600
```

---

## ✅ 检查清单

添加日志后验证：

- [ ] 日志格式统一，都包含 `[VEL_DEBUG]` 标记
- [ ] 使用 `THROTTLE` 避免日志刷屏
- [ ] 记录关键速度变化点（修改前后）
- [ ] 包含必要的上下文信息（模块名、阶段）
- [ ] 编译通过，无警告
- [ ] 运行测试，日志正常输出
- [ ] 可通过 `grep` 轻松过滤

---

## 🎯 总结

通过在关键位置添加调试日志，可以完整追踪速度在 Planning 模块中的计算和传递过程，便于：

1. ✅ 定位速度异常的源头
2. ✅ 理解各模块对速度的影响
3. ✅ 验证参数调整的效果
4. ✅ 诊断速度为零的问题

**建议优先添加日志的模块**:
1. BPP 主节点输出
2. Goal Planner 速度决策
3. Obstacle Cruise Planner
4. Static Obstacle Avoidance

祝调试顺利！🚀

